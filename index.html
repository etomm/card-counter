<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conta Carte Hold'em</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b5" />
  <style>
    :root{--bg:#0a0f0a;--fg:#e9f5ee;--muted:#9fb9ad;--accent:#0b5}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;background:var(--bg);color:var(--fg);}
    header{position:sticky;top:0;background:#0d1410;border-bottom:1px solid #143;padding:.5rem .75rem;z-index:3}
    h1{font-size:1.1rem;margin:.2rem 0}
    .toolbar{display:flex;gap:.5rem;flex-wrap:wrap}
    button{background:#132; color:var(--fg); border:1px solid #264; padding:.45rem .7rem; border-radius:.5rem; cursor:pointer}
    button.primary{background:var(--accent);border-color:#0a4;color:#021}
    #grid{padding:.5rem; display:grid; gap:.5rem; align-items:stretch; justify-items:stretch; justify-content:start}
    .cell{width:100%; height:100%;}
    .card{width:100%; height:100%; border-radius:.4rem; border:1px solid #2a2f2a; display:flex; align-items:center; justify-content:center; background:#0e1510; position:relative; overflow:hidden; cursor:pointer; transition:transform .05s}
    .card:active{transform:scale(.98)}
    .card img{width:100%; height:100%; object-fit:contain; padding:6px; display:block; opacity:.98; filter:drop-shadow(0 0 .2rem #000a)}
    .card.removed{opacity:.22; filter:grayscale(.9) brightness(.7)}
    .placeholder{width:100%; height:100%; border-radius:.4rem; border:1px dashed #263; background:transparent; pointer-events:none; opacity:.18}
    .badge{position:absolute; inset:auto .35rem .35rem auto; background:#0009; color:#fff; font-size:.75rem; padding:.12rem .36rem; border-radius:.35rem}
    .legend{display:flex;gap:1rem; padding:.2rem .75rem; color:var(--muted); font-size:.95rem}
    .status{padding:.4rem .75rem; color:var(--muted)}
    .grid-wrap{width:100vw; max-width:none; margin:0; height:calc(100vh - 120px)}
  </style>
</head>
<body>
  <header>
    <h1>Conta Carte Hold'em</h1>
    <div class="toolbar">
      <button class="primary" id="reset">Reset</button>
      <button id="inverti">Inverti selezione</button>
      <button id="soloVive">Mostra solo vive</button>
      <button id="soloMorte">Mostra solo morte</button>
      <button id="tutte">Mostra tutte</button>
      <button id="mode13x4">13×4</button>
      <button id="mode4x13">4×13</button>
      <button id="modeAuto">Auto</button>
    </div>
    <div class="legend"> 
      <span>Vive: <strong id="count-live">52</strong></span>
      <span>Morte: <strong id="count-dead">0</strong></span>
      <span id="layout-info"></span>
    </div>
  </header>
  <div class="grid-wrap" id="gridWrap">
    <div id="grid" aria-label="Mazzo responsive"></div>
    <div class="status" id="status"></div>
  </div>
  <script>
  const ranks = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];
  const suits = ['S','H','D','C']; // Spade, Hearts, Diamonds, Clubs
  const suitNames = {S:'picche', H:'cuori', D:'quadri', C:'fiori'};

  function suitGlyph(s){ switch(s){ case 'S': return '♠'; case 'H': return '♥'; case 'D': return '♦'; case 'C': return '♣'; } }
  function isRed(s){ return (s==='H'||s==='D'); }
  function inkColor(s){ return isRed(s) ? '#e44747' : '#eaf3ea'; }

  function pip(x, y, s, fontSize, rotate){ const glyph = suitGlyph(s); const rot = rotate ? ` transform='rotate(180 ${x} ${y})'` : ''; return `<text x='${x}' y='${y}' font-size='${fontSize}' text-anchor='middle' dominant-baseline='middle'${rot}>${glyph}</text>`; }

  function cornerIndex(rank, s){
    const c = inkColor(s);
    const tl = `
      <g fill='${c}' font-family='-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif' font-weight='700'>
        <text x='54' y='116' font-size='82'>${rank}</text>
        <text x='54' y='186' font-size='82'>${suitGlyph(s)}</text>
      </g>`;
    const br = `
      <g fill='${c}' font-family='-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif' font-weight='700' transform='rotate(180 560 740)'>
        <text x='560' y='740' font-size='82' text-anchor='end'>${rank}</text>
        <text x='560' y='680' font-size='82' text-anchor='end'>${suitGlyph(s)}</text>
      </g>`;
    return tl + br;
  }

  function pipsForRank(rank, suit){
    const c = inkColor(suit);
    const X = {L:150, CL:240, C:315, CR:390, R:480};
    const Y = {T:160, UT:270, M:440, DB:610, B:720};

    let content = `<g fill='${c}' font-family='-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif' font-weight='700'>`;
    const num = (rank==='A')?1 : (rank==='K'||rank==='Q'||rank==='J'?null : (rank==='10'?10:parseInt(rank)));

    if(rank==='A'){
      content += pip(315, 440, suit, 234, false);
    } else if(num){
      const fs = 108;
      switch(num){
        case 2: content += pip(X.C, Y.T, suit, fs, false) + pip(X.C, Y.B, suit, fs, true); break;
        case 3: content += pip(X.C, Y.T, suit, fs, false) + pip(X.C, Y.M, suit, fs, false) + pip(X.C, Y.B, suit, fs, true); break;
        case 4: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 5: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.C, Y.M, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 6: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 7: content += pip(X.C, Y.T, suit, fs, false) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 8: content += pip(X.C, Y.T, suit, fs, false) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.DB, suit, fs, true) + pip(X.R, Y.DB, suit, fs, true) + pip(X.C, Y.B, suit, fs, true); break;
        case 9: content += pip(X.C, Y.M, suit, fs, false) + pip(X.C, Y.T, suit, fs, false) + pip(X.C, Y.B, suit, fs, true) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.DB, suit, fs, true) + pip(X.R, Y.DB, suit, fs, true) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false); break;
        case 10: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.DB, suit, fs, true) + pip(X.R, Y.DB, suit, fs, true) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
      }
    } else {
      const glyph = suitGlyph(suit);
      content += `<text x='315' y='420' font-size='260' text-anchor='middle' dominant-baseline='middle' opacity='0.95'>${rank}</text>`;
      content += `<text x='315' y='620' font-size='160' text-anchor='middle' dominant-baseline='middle' opacity='0.9'>${glyph}</text>`;
    }

    content += '</g>';
    return content;
  }

  function cardSVG(rank,suit){ const bgStroke = isRed(suit)?'#a44':'#2a3'; return `data:image/svg+xml;utf8,`+encodeURIComponent(`
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 630 880' preserveAspectRatio='xMidYMid meet'>
      <defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0' stop-color='#0f1a12'/><stop offset='1' stop-color='#0a120c'/></linearGradient></defs>
      <rect x='8' y='8' width='614' height='864' rx='36' ry='36' fill='url(#g)' stroke='${bgStroke}' stroke-width='8'/>
      ${cornerIndex(rank, suit)}
      ${pipsForRank(rank, suit)}
    </svg>`); }

  const allDeck = []; for(const r of ranks){ for(const s of suits){ allDeck.push({id:`${r}${s}`, r, s}); } }

  const grid = document.getElementById('grid');
  const gridWrap = document.getElementById('gridWrap');
  const header = document.querySelector('header');
  const stateKey = 'holdem-card-state-v7';
  let removed = new Set(JSON.parse(localStorage.getItem(stateKey) || '[]'));
  let mode = 'auto'; // 'auto' | '13x4' | '4x13'
  let filterMode = 'live'; // 'all' | 'live' | 'dead'

  function cardMatchesFilter(id){ const isDead = removed.has(id); if(filterMode==='all') return true; if(filterMode==='live') return !isDead; if(filterMode==='dead') return isDead; }

  function countsByAxes(){
    // Count cards per suit and per rank that match current filter
    const countsSuit = {S:0,H:0,D:0,C:0};
    const countsRank = {A:0,K:0,Q:0,J:0,10:0,9:0,8:0,7:0,6:0,5:0,4:0,3:0,2:0};
    for(const c of allDeck){ if(cardMatchesFilter(c.id)){ countsSuit[c.s]++; countsRank[c.r]++; } }
    return {countsSuit, countsRank};
  }

  function axes(){
    const {countsSuit, countsRank} = countsByAxes();
    // Full axes for 'all'; for filtered modes, drop only rows/cols with zero matching cards
    const suitsAxis = (filterMode==='all' ? suits : suits.filter(s=> countsSuit[s]>0));
    const ranksAxis = (filterMode==='all' ? ranks : ranks.filter(r=> countsRank[r]>0));
    return {suitsAxis, ranksAxis};
  }

  function render(){
    grid.innerHTML = '';
    const {suitsAxis, ranksAxis} = axes();
    const colsByRank = currentConfig().colsBy === 'rank';

    if(colsByRank){
      // 13×4 style: rows = suitsAxis; cols = ranksAxis; preserve positions with placeholders
      for(const s of suitsAxis){
        for(const r of ranksAxis){
          const id = r + s;
          const wrapper = document.createElement('div'); wrapper.className = 'cell';
          if(cardMatchesFilter(id)){
            const el = document.createElement('button'); el.className = 'card'; el.type = 'button';
            const img = document.createElement('img'); img.alt = `${r} di ${suitNames[s]}`; img.loading = 'lazy'; img.decoding = 'async'; img.src = cardSVG(r, s); el.appendChild(img);
            if(removed.has(id)) el.classList.add('removed');
            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = removed.has(id) ? 'morta' : 'viva'; el.appendChild(badge);
            el.addEventListener('click', ()=>{ if(removed.has(id)) removed.delete(id); else removed.add(id); save(); updateCounts(); render(); layout(); });
            wrapper.appendChild(el);
          } else {
            const ph = document.createElement('div'); ph.className = 'placeholder'; wrapper.appendChild(ph);
          }
          grid.appendChild(wrapper);
        }
      }
    } else {
      // 4×13 style: rows = ranksAxis; cols = suitsAxis
      for(const r of ranksAxis){
        for(const s of suitsAxis){
          const id = r + s;
          const wrapper = document.createElement('div'); wrapper.className = 'cell';
          if(cardMatchesFilter(id)){
            const el = document.createElement('button'); el.className = 'card'; el.type = 'button';
            const img = document.createElement('img'); img.alt = `${r} di ${suitNames[s]}`; img.loading = 'lazy'; img.decoding = 'async'; img.src = cardSVG(r, s); el.appendChild(img);
            if(removed.has(id)) el.classList.add('removed');
            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = removed.has(id) ? 'morta' : 'viva'; el.appendChild(badge);
            el.addEventListener('click', ()=>{ if(removed.has(id)) removed.delete(id); else removed.add(id); save(); updateCounts(); render(); layout(); });
            wrapper.appendChild(el);
          } else {
            const ph = document.createElement('div'); ph.className = 'placeholder'; wrapper.appendChild(ph);
          }
          grid.appendChild(wrapper);
        }
      }
    }
  }

  function currentConfig(){ if(mode === '13x4') return {colsBy:'rank'}; if(mode === '4x13') return {colsBy:'suit'}; const aspect = window.innerWidth / window.innerHeight; return aspect >= 1.2 ? {colsBy:'rank'} : {colsBy:'suit'}; }

  function save(){ localStorage.setItem(stateKey, JSON.stringify([...removed])); }
  function updateCounts(){ const dead = removed.size; const live = 52 - dead; document.getElementById('count-live').textContent = String(live); document.getElementById('count-dead').textContent = String(dead); }

  function layout(){
    const vw = window.innerWidth; const vh = window.innerHeight; const headerH = header.getBoundingClientRect().height; const availH = Math.max(200, vh - headerH - 8);
    gridWrap.style.height = availH + 'px';

    const {suitsAxis, ranksAxis} = axes();
    const cfg = currentConfig();
    const colsTarget = cfg.colsBy==='rank' ? Math.max(1, ranksAxis.length) : Math.max(1, suitsAxis.length);
    const rowsTarget = cfg.colsBy==='rank' ? Math.max(1, suitsAxis.length) : Math.max(1, ranksAxis.length);

    const gap = 8; const paddingX = 16; // account for #grid padding
    const cardW_fromW = Math.floor((vw - paddingX - gap*(colsTarget-1)) / colsTarget);
    const cardH_fromH = Math.floor((availH - gap*(rowsTarget-1)) / rowsTarget);
    const cardW_fromH = Math.floor(cardH_fromH * 63 / 88);

    let cardW;
    if(cfg.colsBy==='suit'){
      // Narrow: ensure full horizontal fill
      cardW = Math.max(48, cardW_fromW);
    } else {
      // Wide: fit both dimensions
      cardW = Math.max(48, Math.min(cardW_fromW, cardW_fromH));
    }
    const cardH = Math.floor(cardW * 88 / 63);

    grid.style.gridTemplateColumns = `repeat(${colsTarget}, ${cardW}px)`;
    grid.style.gridAutoRows = `${cardH}px`;
    document.getElementById('layout-info').textContent = `${colsTarget}×${rowsTarget} ~ ${cardW}×${cardH}px (${cfg.colsBy==='rank'?'13×4-style':'4×13-style'}) [filter:${filterMode}]`;
  }

  // Buttons
  document.getElementById('reset').onclick = ()=>{ removed = new Set(); save(); updateCounts(); render(); layout(); };
  document.getElementById('inverti').onclick = ()=>{ const newSet = new Set(); for(const c of allDeck){ if(!removed.has(c.id)) newSet.add(c.id); } removed = newSet; save(); updateCounts(); render(); layout(); };
  document.getElementById('soloVive').onclick = ()=>{ filterMode='live'; render(); layout(); };
  document.getElementById('soloMorte').onclick = ()=>{ filterMode='dead'; render(); layout(); };
  document.getElementById('tutte').onclick = ()=>{ filterMode='all'; render(); layout(); };
  document.getElementById('mode13x4').onclick = ()=>{ mode='13x4'; render(); layout(); };
  document.getElementById('mode4x13').onclick = ()=>{ mode='4x13'; render(); layout(); };
  document.getElementById('modeAuto').onclick = ()=>{ mode='auto'; render(); layout(); };

  render(); updateCounts(); layout(); window.addEventListener('resize', ()=>{ render(); layout(); });

  if('serviceWorker' in navigator){ window.addEventListener('load', ()=>{ navigator.serviceWorker.register('sw.js'); }); }
  </script>
</body>
</html>