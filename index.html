<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conta Carte Hold'em</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b5" />
  <style>
    :root{--bg:#0a0f0a;--fg:#e9f5ee;--muted:#9fb9ad;--accent:#0b5}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;background:var(--bg);color:var(--fg);}
    header{position:sticky;top:0;background:#0d1410;border-bottom:1px solid #143;padding:.5rem .75rem;z-index:3}
    h1{font-size:1.1rem;margin:.2rem 0}
    .toolbar{display:flex;gap:.5rem;flex-wrap:wrap}
    button{background:#132; color:var(--fg); border:1px solid #264; padding:.45rem .7rem; border-radius:.5rem; cursor:pointer}
    button.primary{background:var(--accent);border-color:#0a4;color:#021}
    #grid{padding:.5rem; display:grid; gap:.5rem; align-items:stretch; justify-items:stretch}
    .cell{width:100%; height:100%;}
    .card{width:100%; height:100%; border-radius:.4rem; border:1px solid #2a2f2a; display:flex; align-items:center; justify-content:center; background:#0e1510; position:relative; overflow:hidden; cursor:pointer; transition:transform .05s}
    .card:active{transform:scale(.98)}
    .card img{width:100%; height:100%; object-fit:contain; padding:4px; display:block; opacity:.98; filter:drop-shadow(0 0 .2rem #000a)}
    .card.removed{opacity:.22; filter:grayscale(.9) brightness(.7)}
    .badge{position:absolute; inset:auto .35rem .35rem auto; background:#0009; color:#fff; font-size:.75rem; padding:.12rem .36rem; border-radius:.35rem}
    .legend{display:flex;gap:1rem; padding:.2rem .75rem; color:var(--muted); font-size:.95rem}
    .status{padding:.4rem .75rem; color:var(--muted)}
    .grid-wrap{max-width:1600px; margin:0 auto; height:calc(100vh - 120px)}
  </style>
</head>
<body>
  <header>
    <h1>Conta Carte Hold'em</h1>
    <div class="toolbar">
      <button class="primary" id="reset">Reset</button>
      <button id="inverti">Inverti selezione</button>
      <button id="soloVive">Mostra solo vive</button>
      <button id="soloMorte">Mostra solo morte</button>
      <button id="tutte">Mostra tutte</button>
      <button id="mode13x4">13×4</button>
      <button id="mode4x13">4×13</button>
      <button id="modeAuto">Auto</button>
    </div>
    <div class="legend"> 
      <span>Vive: <strong id="count-live">52</strong></span>
      <span>Morte: <strong id="count-dead">0</strong></span>
      <span id="layout-info"></span>
    </div>
  </header>
  <div class="grid-wrap" id="gridWrap">
    <div id="grid" aria-label="Mazzo responsive"></div>
    <div class="status" id="status"></div>
  </div>
  <script>
  const ranks = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'];
  const suits = ['S','H','D','C']; // Spade, Hearts, Diamonds, Clubs
  const suitNames = {S:'picche', H:'cuori', D:'quadri', C:'fiori'};

  function suitGlyph(s){ switch(s){ case 'S': return '♠'; case 'H': return '♥'; case 'D': return '♦'; case 'C': return '♣'; } }
  function isRed(s){ return (s==='H'||s==='D'); }
  function inkColor(s){ return isRed(s) ? '#e44747' : '#eaf3ea'; }

  function pip(x, y, s, fontSize, rotate){ const glyph = suitGlyph(s); const rot = rotate ? ` transform='rotate(180 ${x} ${y})'` : ''; return `<text x='${x}' y='${y}' font-size='${fontSize}' text-anchor='middle' dominant-baseline='middle'${rot}>${glyph}</text>`; }

  function cornerIndex(rank, s){
    const c = inkColor(s);
    const tl = `
      <g fill='${c}' font-family='-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif' font-weight='700'>
        <text x='48' y='110' font-size='88'>${rank}</text>
        <text x='48' y='185' font-size='88'>${suitGlyph(s)}</text>
      </g>`;
    const br = `
      <g fill='${c}' font-family='-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif' font-weight='700' transform='rotate(180 580 760)'>
        <text x='580' y='760' font-size='88' text-anchor='end'>${rank}</text>
        <text x='580' y='695' font-size='88' text-anchor='end'>${suitGlyph(s)}</text>
      </g>`;
    return tl + br;
  }

  function pipsForRank(rank, suit){
    const c = inkColor(suit);
    const X = {L:150, CL:240, C:315, CR:390, R:480};
    const Y = {T:160, UT:270, M:440, DB:610, B:720};
    let content = `<g fill='${c}' font-family='-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif' font-weight='700'>`;
    const num = (rank==='A')?1 : (rank==='K'||rank==='Q'||rank==='J'?null : (rank==='10'?10:parseInt(rank)));
    if(rank==='A'){
      content += pip(315, 440, suit, 234, false);
    } else if(num){
      const fs = 108;
      switch(num){
        case 2: content += pip(X.C, Y.T, suit, fs, false) + pip(X.C, Y.B, suit, fs, true); break;
        case 3: content += pip(X.C, Y.T, suit, fs, false) + pip(X.C, Y.M, suit, fs, false) + pip(X.C, Y.B, suit, fs, true); break;
        case 4: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 5: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.C, Y.M, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 6: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 7: content += pip(X.C, Y.T, suit, fs, false) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
        case 8: content += pip(X.C, Y.T, suit, fs, false) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.DB, suit, fs, true) + pip(X.R, Y.DB, suit, fs, true) + pip(X.C, Y.B, suit, fs, true); break;
        case 9: content += pip(X.C, Y.M, suit, fs, false) + pip(X.C, Y.T, suit, fs, false) + pip(X.C, Y.B, suit, fs, true) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.DB, suit, fs, true) + pip(X.R, Y.DB, suit, fs, true) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false); break;
        case 10: content += pip(X.L, Y.T, suit, fs, false) + pip(X.R, Y.T, suit, fs, false) + pip(X.L, Y.UT, suit, fs, false) + pip(X.R, Y.UT, suit, fs, false) + pip(X.L, Y.M, suit, fs, false) + pip(X.R, Y.M, suit, fs, false) + pip(X.L, Y.DB, suit, fs, true) + pip(X.R, Y.DB, suit, fs, true) + pip(X.L, Y.B, suit, fs, true) + pip(X.R, Y.B, suit, fs, true); break;
      }
    } else {
      const glyph = suitGlyph(suit);
      content += `<text x='315' y='420' font-size='260' text-anchor='middle' dominant-baseline='middle' opacity='0.95'>${rank}</text>`;
      content += `<text x='315' y='620' font-size='160' text-anchor='middle' dominant-baseline='middle' opacity='0.9'>${glyph}</text>`;
    }
    content += '</g>';
    return content;
  }

  function cardSVG(rank,suit){ const bgStroke = isRed(suit)?'#a44':'#2a3'; return `data:image/svg+xml;utf8,`+encodeURIComponent(`
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 630 880' preserveAspectRatio='xMidYMid meet'>
      <defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0' stop-color='#0f1a12'/><stop offset='1' stop-color='#0a120c'/></linearGradient></defs>
      <rect x='8' y='8' width='614' height='864' rx='36' ry='36' fill='url(#g)' stroke='${bgStroke}' stroke-width='8'/>
      ${cornerIndex(rank, suit)}
      ${pipsForRank(rank, suit)}
    </svg>`); }

  const allDeck = []; for(const r of ranks){ for(const s of suits){ allDeck.push({id:`${r}${s}`, r, s}); } }

  const grid = document.getElementById('grid');
  const gridWrap = document.getElementById('gridWrap');
  const header = document.querySelector('header');
  const stateKey = 'holdem-card-state-v6';
  let removed = new Set(JSON.parse(localStorage.getItem(stateKey) || '[]'));
  let mode = 'auto'; // 'auto' | '13x4' | '4x13'
  let filterMode = 'live'; // 'all' | 'live' | 'dead' ; default to live as per current behavior

  function cardMatchesFilter(id){
    const isDead = removed.has(id);
    if(filterMode==='all') return true;
    if(filterMode==='live') return !isDead;
    if(filterMode==='dead') return isDead;
  }

  function presentSets(){
    // Sets with at least one card matching filter
    const present = allDeck.filter(c=> cardMatchesFilter(c.id));
    const suitsSet = new Set(present.map(c=> c.s));
    const ranksSet = new Set(present.map(c=> c.r));
    return {suits:[...suitsSet], ranks:[...ranksSet]};
  }

  function render(){
    grid.innerHTML = '';
    const {suits, ranks} = presentSets();

    let suitsAxis = ['S','H','D','C'].filter(s=> suits.includes(s));
    let ranksAxis = ['A','K','Q','J','10','9','8','7','6','5','4','3','2'].filter(r=> ranks.includes(r));

    const list = [];
    const colsByRank = currentConfig().colsBy === 'rank';
    if(colsByRank){
      // 13x4 style: rows=suits, cols=ranks
      for(const s of suitsAxis){ for(const r of ranksAxis){ const id = r + s; if(cardMatchesFilter(id)) list.push({r,s}); } }
    } else {
      // 4x13 style: rows=ranks, cols=suits
      for(const r of ranksAxis){ for(const s of suitsAxis){ const id = r + s; if(cardMatchesFilter(id)) list.push({r,s}); } }
    }

    for(const cs of list){
      const id = cs.r + cs.s;
      const wrapper = document.createElement('div'); wrapper.className = 'cell';
      const el = document.createElement('button'); el.className = 'card'; el.type = 'button';
      const img = document.createElement('img'); img.alt = `${cs.r} di ${suitNames[cs.s]}`; img.loading = 'lazy'; img.decoding = 'async'; img.src = cardSVG(cs.r, cs.s); el.appendChild(img);
      if(removed.has(id)) el.classList.add('removed');
      const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = removed.has(id) ? 'morta' : 'viva'; el.appendChild(badge);
      el.addEventListener('click', ()=>{ if(removed.has(id)) removed.delete(id); else removed.add(id); save(); updateCounts(); render(); layout(); });
      wrapper.appendChild(el); grid.appendChild(wrapper);
    }
  }

  function currentConfig(){
    if(mode === '13x4') return {colsBy:'rank'};
    if(mode === '4x13') return {colsBy:'suit'};
    const aspect = window.innerWidth / window.innerHeight;
    return aspect >= 1.2 ? {colsBy:'rank'} : {colsBy:'suit'};
  }

  function save(){ localStorage.setItem(stateKey, JSON.stringify([...removed])); }
  function updateCounts(){ const dead = removed.size; const live = 52 - dead; document.getElementById('count-live').textContent = String(live); document.getElementById('count-dead').textContent = String(dead); }

  function layout(){
    const vw = window.innerWidth; const vh = window.innerHeight; const headerH = header.getBoundingClientRect().height; const availH = Math.max(200, vh - headerH - 8);
    gridWrap.style.height = availH + 'px';

    const {suits, ranks} = presentSets();
    const cfg = currentConfig();
    let colsTarget = cfg.colsBy==='rank' ? Math.max(1, ranks.length) : Math.max(1, suits.length);
    let rowsTarget = cfg.colsBy==='rank' ? Math.max(1, suits.length) : Math.max(1, ranks.length);

    const gap = 8; const paddingX = 16;
    const cardW_fromW = Math.floor((vw - paddingX - gap*(colsTarget-1)) / colsTarget);
    const cardH_fromH = Math.floor((availH - gap*(rowsTarget-1)) / rowsTarget);
    const cardW_fromH = Math.floor(cardH_fromH * 63 / 88);

    let cardW;
    if(cfg.colsBy==='suit'){
      // Narrow mode: prioritize width to fill horizontally; allow vertical scroll if needed
      cardW = Math.max(36, cardW_fromW);
    } else {
      // Wide mode: maximize without overflow using min(width,height-driven)
      cardW = Math.max(36, min(cardW_fromW, cardW_fromH));
    }
    const cardH = Math.floor(cardW * 88 / 63);

    grid.style.gridTemplateColumns = `repeat(${colsTarget}, ${cardW}px)`;
    grid.style.gridAutoRows = `${cardH}px`;
    document.getElementById('layout-info').textContent = `${colsTarget}×${rowsTarget} ~ ${cardW}×${cardH}px (${cfg.colsBy==='rank'?'13×4-style':'4×13-style'}) [filter:${filterMode}]`;
  }

  function min(a,b){ return a<b?a:b; }

  // Buttons
  document.getElementById('reset').onclick = ()=>{ removed = new Set(); save(); updateCounts(); render(); layout(); };
  document.getElementById('inverti').onclick = ()=>{ const newSet = new Set(); for(const c of allDeck){ if(!removed.has(c.id)) newSet.add(c.id); } removed = newSet; save(); updateCounts(); render(); layout(); };
  document.getElementById('soloVive').onclick = ()=>{ filterMode='live'; render(); layout(); };
  document.getElementById('soloMorte').onclick = ()=>{ filterMode='dead'; render(); layout(); };
  document.getElementById('tutte').onclick = ()=>{ filterMode='all'; render(); layout(); };
  document.getElementById('mode13x4').onclick = ()=>{ mode='13x4'; render(); layout(); };
  document.getElementById('mode4x13').onclick = ()=>{ mode='4x13'; render(); layout(); };
  document.getElementById('modeAuto').onclick = ()=>{ mode='auto'; render(); layout(); };

  render(); updateCounts(); layout(); window.addEventListener('resize', ()=>{ render(); layout(); });

  if('serviceWorker' in navigator){ window.addEventListener('load', ()=>{ navigator.serviceWorker.register('sw.js'); }); }
  </script>
</body>
</html>